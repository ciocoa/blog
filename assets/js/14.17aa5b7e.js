(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{412:function(t,v,a){"use strict";a.r(v);var _=a(56),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[t._v("#")]),t._v(" 事件")]),t._v(" "),a("p",[t._v("在 HTML 文档或浏览器发生的一种交互操作，常见的有加载事件，鼠标/键盘事件，自定义事件等。")]),t._v(" "),a("h2",{attrs:{id:"事件传播"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件传播"}},[t._v("#")]),t._v(" 事件传播")]),t._v(" "),a("p",[t._v("事件会经历三个阶段")]),t._v(" "),a("ul",[a("li",[t._v("捕获阶段：事件从 window 开始，依次往下触发，直到目标元素")]),t._v(" "),a("li",[t._v("目标阶段：事件已位于目标元素")]),t._v(" "),a("li",[t._v("冒泡阶段：事件从目标元素往上传播，直到到 window")])]),t._v(" "),a("p",[a("code",[t._v("event.stopPropagation")]),t._v("方法可以阻止事件在捕获或冒泡阶段的进一步传播")]),t._v(" "),a("h2",{attrs:{id:"事件模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件模型"}},[t._v("#")]),t._v(" 事件模型")]),t._v(" "),a("ul",[a("li",[t._v("原始事件模型：- HTML 中直接绑定"),a("code",[t._v("onclick")]),t._v("，或 JS 中绑定。绑定速度快，不支持捕获，同一类型事件只能绑定一次")]),t._v(" "),a("li",[t._v("标准事件模型：- 绑定监听函数"),a("code",[t._v("addEventListener")]),t._v("，可以在一个 DOM 元素上绑定多个事件处理器")]),t._v(" "),a("li",[t._v("IE 事件模型：- "),a("code",[t._v("attachEvent")]),t._v("事件处理阶段，事件到达目标元素，触发目标元素的监听函数。事件冒泡阶段，从目标元素冒泡到 Document，依次检查经过的节点是否绑定了事件监听函数，有则执行")])]),t._v(" "),a("h2",{attrs:{id:"事件委托"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件委托"}},[t._v("#")]),t._v(" 事件委托")]),t._v(" "),a("p",[t._v("将一个元素响应事件的函数委托到另一个元素，事件委托是在事件流的冒泡阶段完成，会把一个或一组元素的事件委托到父层或更外层元素上，当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上执行函数\n一般运用于整个列表的响应事件，减少整个页面所需内存提升性能，动态绑定，减少重复性工作")])])}),[],!1,null,null,null);v.default=e.exports}}]);