(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{409:function(t,a,s){"use strict";s.r(a);var v=s(56),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"作用域和闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域和闭包"}},[t._v("#")]),t._v(" 作用域和闭包")]),t._v(" "),s("h2",{attrs:{id:"作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),s("p",[t._v("作用域就是可以有效访问变量或函数的区域，js 有三种类型的作用域：")]),t._v(" "),s("ul",[s("li",[t._v("全局作用域，即在全局命名空间里声明的变量或函数，在代码的任何地方都能访问")]),t._v(" "),s("li",[t._v("函数作用域，也叫局部作用域即在函数内部进行声明，每个函数都有自己的上下文和可变对象，这些环境用于存储上下文的变量、参数、函数声明等")]),t._v(" "),s("li",[t._v("块级作用域，即在"),s("code",[t._v("{}")]),t._v("中使用"),s("code",[t._v("let")]),t._v("和"),s("code",[t._v("const")]),t._v("声明的变量，只能在其中访问")])]),t._v(" "),s("h2",{attrs:{id:"作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),s("p",[t._v("作用域也可以看作是一组用于查找变量的规则，变量在当前作用域中不存在，则向上级作用域查找，如果仍不存在则再次向上查找，直至全局作用域，这种查找也叫作用域链")]),t._v(" "),s("h2",{attrs:{id:"闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),s("p",[t._v("闭包就是一个函数在声明时能记住当前作用域，上级作用域及其上声明的变量函数等直至全局作用域。闭包是在声明函数时创建的作用域，可以在一个内层函数中访问到其他外层函数，简单理解为定义在函数内部的函数，函数作为返回值始终保持在内存中，实际应用于封装变量，收敛权限。闭包可能造成内存空间无法被 gc 回收，内存消耗过高甚至内存泄露。")]),t._v(" "),s("p",[t._v("柯里化函数的目的在于避免频繁的调用具有相同参数函数，轻松重用")])])}),[],!1,null,null,null);a.default=_.exports}}]);