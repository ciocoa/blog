(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{412:function(e,v,_){"use strict";_.r(v);var t=_(56),s=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"异步和单线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异步和单线程"}},[e._v("#")]),e._v(" 异步和单线程")]),e._v(" "),_("p",[e._v("JS 主要时用来与用户交互以及操作 DOM 的，这决定了它只能是单线程，即同一时间只能处理一个事务，所有任务需要排队，只有前一个任务结束后才执行下一个任务。")]),e._v(" "),_("p",[e._v("H5 提供了新的 Web Worker 标准，允许创建多线程，但子线程受到主线程控制，且不能操作 DOM。")]),e._v(" "),_("p",[e._v("JS 中所有任务可以分为")]),e._v(" "),_("ul",[_("li",[e._v("同步任务：立即执行的任务，直接进入主线程执行，形成一个执行栈")]),e._v(" "),_("li",[e._v("异步任务："),_("code",[e._v("ajax")]),e._v("函数，"),_("code",[e._v("setTimeout")]),e._v("定时函数等，进入任务队列")])]),e._v(" "),_("p",[e._v("主线程内的任务执行完毕再读取任务队列执行异步任务，如此不断重复就是事件循环")]),e._v(" "),_("p",[e._v("异步任务可以细分为宏任务和微任务，先执行宏任务，遇到微任务则放到微任务的执行对列，当宏任务执行完毕，再查看微任务的事件队列并依次执行。")]),e._v(" "),_("ul",[_("li",[e._v("微任务："),_("code",[e._v("Promise.then")]),e._v(" "),_("code",[e._v("process.nextTick（node.js）")])]),e._v(" "),_("li",[e._v("宏任务："),_("code",[e._v("script（外层同步代码）")]),e._v(" "),_("code",[e._v("setTimeout/setInterval")]),e._v(" "),_("code",[e._v("UI rendering（UI 事件）")]),e._v(" "),_("code",[e._v("postMessage/MessageChannel")]),e._v(" "),_("code",[e._v("setImmediate、IO（node.js）")])])]),e._v(" "),_("h2",{attrs:{id:"async-await"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[e._v("#")]),e._v(" async await")]),e._v(" "),_("p",[_("code",[e._v("async")]),e._v("函数用来声明一个异步方法，返回一个"),_("code",[e._v("promise")]),e._v("对象，"),_("code",[e._v("await")]),e._v("等待异步方法执行，（阻塞后面的代码）后面若是一个"),_("code",[e._v("promise")]),e._v("对象，返回该对象的结果，若不是，就直接返回对应的值")])])}),[],!1,null,null,null);v.default=s.exports}}]);